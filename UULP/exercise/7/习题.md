#### 7.1

1. 中断，没有输出 "Alarm received from kernel".
2. Done.
3. 工作正常。

#### 7.2

参见 [信号中断 与 慢系统调用](http://blog.csdn.net/benkaoya/article/details/17262053#)。

#### 7.3

猜想：sigprocmask 直接让进程无视信号；ISIG 则在终端驱动程序拦截信号，并无法操作系统或用户通过其它途径发送信号，可参见编程练习 6.8. sigprocmask 所要 block 的信号是可选的；ISIG 则拦截所有键盘信号：`INTR`, `QUIT`, `SUSP`, `DSUSP`.

#### 7.4

TODO

#### 7.5

猜想：阻塞时，则进程始终立马执行 move_msg, 达到移动的上限，哪怕计时器间隔重新变得比执行 move_msg 长，也还要剩下的所阻塞信号，造成一定的延迟；如果递归调用，则 MESSAGE 有可能会跳跃地刷新，毕竟递归调用不是可重入的，pos 会大跃进地被更改。阻塞。

#### 7.6

猜想：如果程序用于接收 getch() 的变量匹配到 EOF 时就会退出，确实。

#### 7.7

由于共享 `dir` 变量，的确彼此会有所干涉的风险。阻塞大法好；因为不可重入，所以递归调用行不通。